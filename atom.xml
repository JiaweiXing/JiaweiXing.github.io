<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邢佳伟的博客</title>
  
  <subtitle>行者无疆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xingjiawei.cn/"/>
  <updated>2017-12-21T02:26:04.000Z</updated>
  <id>https://xingjiawei.cn/</id>
  
  <author>
    <name>邢佳伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-单例</title>
    <link href="https://xingjiawei.cn/2017/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
    <id>https://xingjiawei.cn/2017/12/20/设计模式-单例/</id>
    <published>2017-12-20T08:23:27.000Z</published>
    <updated>2017-12-21T02:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结常用的单例写法，C#为例<br><a id="more"></a></p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>GoF对单例模式的定义：保证一个类，只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。<h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><code>是否依赖初始化</code> : 是<br><code>是否多线程安全</code> : 否<br><code>总结</code> :<br>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br>e.g.<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                  instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">Unity3d 中e.g.</span><br><span class="line">``` csharp</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">            instance = <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="简单安全线程"><a href="#简单安全线程" class="headerlink" title="简单安全线程"></a>简单安全线程</h3><p><code>是否依赖初始化</code> : 是<br><code>是否多线程安全</code> : 是<br><code>总结</code> :<br>上述实现是线程安全的。这个线程在共享的object上取出了一把锁，然后在创建实例以前检查这个实例是否被创建了。这个保护了内存屏障问题（lock保证了所有的读取操作是在LOCK获得以后发生的，所有的unlock保证了所有的写操作在lock 释放以后发生的），这样就保证了一个线程只能创建一个实例（每次只有一个线程在这段代码中运行），不巧的是，性能上来说，锁变成了每次都必须的当这个实例被响应的时候。<br>　　注意除了在锁当中锁住typeof(Singleton)这种类型的以外，我锁住了一个静态私有的变量，对于这个类来说。如果是锁 的一个对象的话，其他的类可以进入并且锁住（比如Type）这样会造成性能风险的问题甚至死锁。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 "加锁"，</span></span><br><span class="line">            <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">            <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象"解锁"</span></span><br><span class="line">            <span class="keyword">lock</span> (locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程安全（双重锁定）"><a href="#线程安全（双重锁定）" class="headerlink" title="线程安全（双重锁定）"></a>线程安全（双重锁定）</h3><p><code>是否依赖初始化</code> : 是<br><code>是否多线程安全</code> : 是<br><code>总结</code> : </p><ul><li>这个方法java不可行，java的方法可见<a href="https://www.cnblogs.com/damonhuang/p/5431866.html" target="_blank" rel="noopener">https://www.cnblogs.com/damonhuang/p/5431866.html</a></li><li>需要写得很精确，不然很容易报错，实际开发过程很少用到。<br>e.g.<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 "加锁"，</span></span><br><span class="line">           <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">           <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象"解锁"</span></span><br><span class="line">           <span class="comment">// 双重锁定只需要一句判断就可以了</span></span><br><span class="line">           <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">lock</span> (locker)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                   <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程安全且不需要锁"><a href="#线程安全且不需要锁" class="headerlink" title="线程安全且不需要锁"></a>线程安全且不需要锁</h3><p><code>是否依赖初始化</code> : 否<br><code>是否多线程安全</code> : 是<br><code>总结</code> : </p><ul><li>没有加锁，执行效率会提高。</li><li>类加载时就初始化，浪费内存。<br>e.g.<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> (<span class="params"></span>)</span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结常用的单例写法，C#为例&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://xingjiawei.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例" scheme="https://xingjiawei.cn/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Shader学习笔记（一）</title>
    <link href="https://xingjiawei.cn/2017/12/06/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://xingjiawei.cn/2017/12/06/Shader学习笔记（一）/</id>
    <published>2017-12-06T02:40:13.000Z</published>
    <updated>2017-12-20T08:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍图形开发流程和CG语法<br><a id="more"></a></p><h2 id="图形编程历史"><a href="#图形编程历史" class="headerlink" title="图形编程历史"></a><a href="https://www.cnblogs.com/maple-share/p/5382228.html" target="_blank" rel="noopener">图形编程历史</a></h2><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><h3 id="目前最新的可编程图形硬件支持功能："><a href="#目前最新的可编程图形硬件支持功能：" class="headerlink" title="目前最新的可编程图形硬件支持功能："></a>目前最新的可编程图形硬件支持功能：</h3><ul><li>支持顶点和片段的可编程能力 </li><li>支持IEEE32位的浮点运算（IEEE32是国际电工委员会置顶的浮点书表示方式，主要内容是用四个字节来表示浮点数，可以表示的数据的负数范围是(-2<em>2)^128~-2^127,2^-127~2</em>2^128） </li><li>支持四元向量和四阶矩阵 </li><li>提供分支和循环的控制语句 </li><li>具有高带宽的内存处理能力 </li><li>支持1D,2D,3D的纹理查询和使用能力，而且速度非常快</li><li>支持绘制到纹理功能<h3 id="渲染流水线-1"><a href="#渲染流水线-1" class="headerlink" title="渲染流水线"></a>渲染流水线</h3></li><li><code>含义</code>： 计算机需要从一系列的顶点数据、纹理等信息出发、生成（或者说渲染）一张二维图像的过程。</li><li>渲染流程分为三个阶段<ul><li><code>应用程序阶段</code>：（CPU）<ul><li><code>准备数据</code> eg.摄像机的位置、视椎体、场景中的模型和光源等等</li><li><code>culling</code> 粗粒度剔除 eg.将不可见的物体剔除</li><li><code>输出</code> 输出渲染所需的几何信息（点、线、三角面），即<code>渲染图元</code>。</li></ul></li><li><code>几何阶段</code>：（GPU）<ul><li><code>处理渲染图元</code>进行逐顶点、逐多边形的操作。顶点坐标转换到屏幕空间。</li><li><code>输出</code>屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息。</li></ul></li><li><code>光栅化阶段</code>：（GPU）<ul><li>对上阶段的数据进行插值，再进行逐像素的处理。<h3 id="CPU与GPU之间的通信"><a href="#CPU与GPU之间的通信" class="headerlink" title="CPU与GPU之间的通信"></a>CPU与GPU之间的通信</h3></li></ul></li></ul></li><li><code>CPU流水线</code>（即应用阶段）<ul><li>把数据加载到显存里</li><li>设置渲染状态</li><li>调用Draw Call（发起方是CPU，接收方是GPU）  </li></ul></li><li><code>GPU流水线</code>（即几何阶段和光栅化阶段）<br><img src="https://raw.githubusercontent.com/JiaweiXing/MarkdownImage/master/Image/GPU%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt=""></li><li><code>顶点着色器</code> ： 必选，可编程，通常用于实现顶点坐标的变换，计算顶点颜色。</li><li><code>曲面细分着色器</code> ：可选，用于细分图元。</li><li><code>几何着色器</code> ：可选，用于逐图元的着色操作,或者用于产生更多的图元。</li><li><code>裁剪</code> ： 可配置，将不是摄像机视野中的顶点裁剪掉。</li><li><code>屏幕映射</code> ： 不可编程，不可配置。把每个图元的坐标转换到屏幕坐标系。</li><li><code>三角设置</code>和<code>三角形遍历</code>阶段都是固定函数的阶段。</li><li><code>片元着色器</code> ：可编程，用于实现逐片元的着色操作。</li><li><code>逐片元操作</code> ： 可配置，eg.颜色修改，深度缓，冲进行混合等。<h3 id="三种语言："><a href="#三种语言：" class="headerlink" title="三种语言："></a>三种语言：</h3></li><li>OpenGl的GLSL </li><li>Direct3D的HLSL </li><li>NVIDIA的CG（CG编写的可同时兼容OpenGL和Direct平台）<h3 id="GPU流水线的两个重要阶段"><a href="#GPU流水线的两个重要阶段" class="headerlink" title="GPU流水线的两个重要阶段"></a>GPU流水线的两个重要阶段</h3></li><li><code>顶点着色器</code><ul><li>输入： GPU前端模块提取图元信息（顶点位置，法线向量，纹理坐标（uv））等。</li><li>操作： 顶点坐标空间转换，法向量空间转换，光照计算等（现在光照计算一般在片段着色器，比较细），然后将计算好的数据传入指定寄存器中。 </li></ul></li><li><code>片元着色器</code><ul><li>输入：顶点着色器传入的数据。</li><li>操作：光照计算，uv扰动，纹理采样等，最后输出当前片段的颜色给光栅化阶段（片段着色器是对每个独立的颜色进行操作的）。 <h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2>推荐《3D数学基础：图形与游戏开发》</li></ul></li><li><a href="http://www.jianshu.com/p/6cc5ff4826dd" target="_blank" rel="noopener">数学基础一</a></li><li><a href="http://www.jianshu.com/p/8faf8389608d" target="_blank" rel="noopener">数学基础二</a><h2 id="CG语言基础"><a href="#CG语言基础" class="headerlink" title="CG语言基础"></a>CG语言基础</h2></li><li>CG语言的特性：<br>Cg是一种类C的语言，他沿用了大量的C语言特性，但是也有不同之处。Cg语言是脚本性语言，不能编译，调试和断点；并且Cg语言的主要用途是绘制像素颜色到屏幕上，他不能处理文字类的内容。Cg语言对单精度浮点的数据类型是非常敏感的；Cg语言因为GPU的并发特性所以导致Cg语言的所有执行过程是并发式的；</li><li><p>CG语法</p><ul><li><p>基础数据类型 ：</p><ul><li><p>float ： 32位浮点数据</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> _Angle = <span class="number">1.0</span></span><br></pre></td></tr></table></figure></li><li><p>half ： 16位浮点数据</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half _Angle = <span class="number">1.0</span></span><br></pre></td></tr></table></figure></li><li><p>int ： 32位整形数据</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> _Angle = <span class="number">1</span></span><br><span class="line">    ``` </span><br><span class="line">- fixed ： <span class="number">12</span>位浮点数据</span><br><span class="line">    ``` glsl</span><br><span class="line">    fixed _Angle = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>bool ： 布尔数据，用于判断</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_Angle == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  colors = diffuses.rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Sampler  纹理对象，6类 ： Sampler，sampler1D,sampler2D,sampler3D,samplerCUBE和samplerRECT</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample2D _Diffuse;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特殊的数据类型</p><ul><li><p>向量 ： 一共拥有4种维度的向量，1-4之间</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 a = float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>矩阵 ： 行和列都不得大于4和不得小于1</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    float2*<span class="number">2</span> a = &#123;<span class="built_in">sin</span>@,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    ``` </span><br><span class="line">    `矩阵在赋值的时候一定要人为的分开行与行之间的关系，但是程序只认识顺序的赋值`</span><br><span class="line">- 数组 ： 因为CG是显卡操作语，没有内存，所以声明的时候要制定大小</span><br><span class="line">    ``` glsl</span><br><span class="line">    float2 b[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> arrayLen = b.<span class="built_in">length</span>; <span class="comment">// 结果是2</span></span><br><span class="line">    <span class="type">float</span> m[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    arrayLen = m.<span class="built_in">length</span>;<span class="comment">// 结果是3；</span></span><br><span class="line">    arrayLen = m[<span class="number">1</span>].<span class="built_in">length</span>;<span class="comment">// 结果是4；</span></span><br><span class="line">    ``` </span><br><span class="line">-  结构体 ： 数据封装作用</span><br><span class="line">    ``` glsl</span><br><span class="line">    struct a2v &#123;</span><br><span class="line">      float4 vertex : POSITION;</span><br><span class="line">      float3 normal : NORMAL;</span><br><span class="line">      float4 texcoord : TEXCOORD0;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></li><li><p>表达式和控制语句</p><ul><li>关系操作符 ：&lt;,&gt;,&lt;=,&gt;=，!=,==,</li><li>逻辑操作符 ：&amp;&amp;，||，！ </li><li>数学操作符 ：+，—，*，/，% </li><li><p>移位操作符 ：&gt;&gt; </p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int2 a = int2(<span class="number">0.0</span>,<span class="number">0.0</span>); </span><br><span class="line">int2 b = a&gt;&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>Swizzle操作符：</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4(a, b, c, d).xyz    等价于  float3(a, b, c)</span><br></pre></td></tr></table></figure></li><li><p>控制流语句 ：if ，if-else while ，for，break</p><ul><li>点操作符：只针对向量和结构  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v2f o;</span><br><span class="line">  o.pos = UnityObjectToClipPos(v.vertex);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>行参修饰词：</p><ul><li>in: 表示当前行参是只能输入的； </li><li>out：表示当前行参用来输出数据的; </li><li>inout: 表示可以进行输入和输出；</li></ul></li><li>离散数据图元信息：<code>uniform</code><ul><li>只读性，只要标有uniform标签的变量，这个变量我们就不能初始化也不能修改其内容；</li><li>使用范围特性，只能存在于入口函数的行参上或者是全局的变量身上； </li><li>他只能支持引擎向着色器传入的数据，不能向外提交数据；</li></ul></li></ul></li><li>语义<br><img src="https://github.com/JiaweiXing/MarkdownImage/raw/master/Image/%E8%AF%AD%E4%B9%89.png" alt=""></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍图形开发流程和CG语法&lt;br&gt;
    
    </summary>
    
    
      <category term="Shader" scheme="https://xingjiawei.cn/tags/Shader/"/>
    
      <category term="学习笔记" scheme="https://xingjiawei.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Unity热更新——toLua的使用</title>
    <link href="https://xingjiawei.cn/2017/07/03/Unity%E7%83%AD%E6%9B%B4%E6%96%B0%E2%80%94%E2%80%94toLua%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xingjiawei.cn/2017/07/03/Unity热更新——toLua的使用/</id>
    <published>2017-07-03T02:40:13.000Z</published>
    <updated>2017-12-20T08:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>热更新方案介绍和一个入门例子。<br><a id="more"></a></p><h2 id="热更新原理和热更新方案介绍"><a href="#热更新原理和热更新方案介绍" class="headerlink" title="热更新原理和热更新方案介绍"></a>热更新原理和热更新方案介绍</h2><p><a href="http://blog.csdn.net/guofeng526/article/details/52662994" target="_blank" rel="noopener">http://blog.csdn.net/guofeng526/article/details/52662994</a></p><h2 id="Lua环境安装"><a href="#Lua环境安装" class="headerlink" title="Lua环境安装"></a>Lua环境安装</h2><ul><li>Linux系统上安装<br>Linux&amp;Mac上安装。只需要下载源码包并在终端上解压编译即可（以5.3.0版本为例）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li><p>Mac OS X系统上安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>Windows系统上安装Lua</p></li></ul><p>windows下可以使用一个叫”SciTE”的IDE环境来执行lua程序，下载地址为：</p><p>Github 下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases" target="_blank" rel="noopener">https://github.com/rjpcomputing/luaforwindows/releases</a><br>双击安装即可。</p><p>Lua官方推荐的方法使用LuaDist:<a href="http://luadist.org" target="_blank" rel="noopener">http://luadist.org</a></p><h2 id="Lua语法"><a href="#Lua语法" class="headerlink" title="Lua语法"></a>Lua语法</h2><p><a href="http://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/lua/lua-tutorial.html</a></p><h2 id="C-与Lua语法的区别"><a href="#C-与Lua语法的区别" class="headerlink" title="C#与Lua语法的区别"></a>C#与Lua语法的区别</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><table><thead><tr><th style="text-align:left">Site</th><th style="text-align:left">Tag</th></tr></thead><tbody><tr><td style="text-align:left">声明变量</td><td style="text-align:left">直接声明，不需要public int之类的</td></tr><tr><td style="text-align:left">｛｝</td><td style="text-align:left">do end </td></tr><tr><td style="text-align:left">nil</td><td style="text-align:left">表示无效值(在条件表达式中相当于false)</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:left">fasle和true</td></tr><tr><td style="text-align:left">number</td><td style="text-align:left">表示双精度的实浮点数</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">字符串由一对双引号或单引号来表示</td></tr><tr><td style="text-align:left">function</td><td style="text-align:left">由C或Lua编写的函数</td></tr><tr><td style="text-align:left">userdata</td><td style="text-align:left">表示任意储存在变量中的C数据结构</td></tr><tr><td style="text-align:left">thread</td><td style="text-align:left">表示执行的独立线路，用于执行协同程序</td></tr><tr><td style="text-align:left">注释</td><td style="text-align:left">单行注释用：–多行注释用：–[[  –]]</td></tr></tbody></table><p>后续我会补全</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><code>sublime</code></p><p><code>Nodepad++</code></p><p><code>Vs code</code></p><p><code>...</code></p><h2 id="C-和Lua之间的调用"><a href="#C-和Lua之间的调用" class="headerlink" title="C#和Lua之间的调用"></a>C#和Lua之间的调用</h2><h3 id="C-调用lua-LuaState-变量名-函数名"><a href="#C-调用lua-LuaState-变量名-函数名" class="headerlink" title="C#调用lua:LuaState[变量名/函数名]"></a><code>C#调用lua</code>:LuaState[变量名/函数名]</h3><p>1.LuaState</p><ul><li><p>执行lua代码段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DoString(String)</span><br><span class="line">DoFile(.lua文件名)</span><br><span class="line">Require（.lua文件名（但没有.lua后缀））</span><br></pre></td></tr></table></figure></li><li><p>获取lua函数或者表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LuaFunction func = lua.GetFunction(函数名); 或者  LuaFunction func = lua[函数名] as LuaFunction;</span><br><span class="line">LuaTable table = lua.GetTable(表名);</span><br></pre></td></tr></table></figure></li><li><p>Start():如果需要使用wrap,则需要调用该方法</p></li></ul><p>2.LuaFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call();</span><br></pre></td></tr></table></figure></p><p>3.LuaTable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LuaTable[变量名/函数名]</span><br><span class="line">ToArray()</span><br></pre></td></tr></table></figure></p><h3 id="lua调用c"><a href="#lua调用c" class="headerlink" title="lua调用c#"></a><code>lua调用c#</code></h3><p>在C#中将引用传递到lua中</p><p>1.通过”.”来使用非静态的变量以及静态的变量与方法</p><p>2.通过”:”来使用非静态的方法</p><p>3.通过”{}”来传递数组给c#</p><p>4.创建GameObject：newObject(变量)</p><p>5.摧毁GameObject：destroy(变量) </p><p>6.获取组件：GetComponent(‘LuaBehaviour’)</p><h2 id="LuaFramework"><a href="#LuaFramework" class="headerlink" title="LuaFramework"></a>LuaFramework</h2><p>我们只需要在tolua里面写属于自己模块部分的逻辑就能简单的实现热更新。</p><p>eg.<br><img src="https://ooo.0o0.ooo/2017/07/03/5959af3a72d72.png" alt=""></p><p><a href="http://www.ulua.org/" target="_blank" rel="noopener">Lua官方地址</a></p><ul><li>从<a href="https://github.com/topameng/tolua" target="_blank" rel="noopener">https://github.com/topameng/tolua</a>上把代码下载下来，可以clone也可以直接下载zip并解压</li><li>把Assets下的文件复制到项目里的Assets目录下</li><li>把Unity5.x下的文件也复制过去，覆盖掉Plugins目录（OSX系统需要注意是合并而不是替换）</li><li>Assets\ToLua\Examples这里面一共是tolua作者给的24个例子<br>（关于例子的介绍和解释在这里：<a href="http://doc.ulua.org/article/ulua/toluadeexamples01helloworld.html" target="_blank" rel="noopener">http://doc.ulua.org/article/ulua/toluadeexamples01helloworld.html</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;热更新方案介绍和一个入门例子。&lt;br&gt;
    
    </summary>
    
    
      <category term="ToLua" scheme="https://xingjiawei.cn/tags/ToLua/"/>
    
  </entry>
  
</feed>
